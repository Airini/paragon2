Filepath: mp/Player.para
["./","/home/niklas/src/paragon/lib","."]
Parsing complete!
Resolving import: import java.lang.*;
Resolving import: import java.security.*;
Resolving import: import java.lang.String;
Checking for ./java/lang/String.pi
Found ./java/lang/String.pi
Resolving import: import java.lang.IllegalArgumentException;
Checking for ./java/lang/IllegalArgumentException.pi
Found ./java/lang/IllegalArgumentException.pi
Resolving import: import java.lang.IndexOutOfBoundsException;
Checking for ./java/lang/IndexOutOfBoundsException.pi
Found ./java/lang/IndexOutOfBoundsException.pi
Resolving import: import mp.*;
Resolving import: import mp.*;
Renaming atom: GameState.GameEnded
Renaming atom: TrustedDeclassifier.Declassify
Name resolution complete!
package mp;
import java.security.*;
import java.lang.String;
import java.lang.IllegalArgumentException;
import java.lang.IndexOutOfBoundsException;
import mp.*;
public class Player
{
  public static final policy atEndGame = {mp.Channel.channel: mp.GameState.GameEnded};
  public static final policy declass = {mp.Channel.channel: mp.TrustedDeclassifier.Declassify};
  public static final policy secret = atEndGame + declass;
  public static final policy everyone = mp.Channel.channelP;
  public static final ?everyone int Z_BITLENGTH = 32;
  private static final ?everyone int DECKSIZE = 8;
  private ?secret mp.PHCrypto<secret> ph = null;
  private ?everyone mp.PHCrypto<everyone> rph = null;
  private ?everyone boolean[]<everyone> available;
  private ?atEndGame int[]<atEndGame> hand;
  private ?everyone int ncards = 0;
  private ?everyone java.lang.String name;
  private ?everyone int nlength = 3;
  private ?everyone int timestamp = 0;
  private ?everyone int k = 0;
  private final ?everyone mp.DNCChain<everyone> chain;
  private ?everyone mp.DABigInteger<everyone> z = mp.DABigInteger.<everyone>ZERO();
  private final ?everyone java.security.KeyPair<everyone, secret> keyPair;
  private ?secret byte[]<secret> p;
  private ?everyone byte[]<everyone> rPerm;
  private ?secret mp.PermutationMatrix<secret> matrix;
  private ?secret mp.PermutationMatrix<secret> matrixCopy;
  private ?secret mp.PHEPermutationMatrix<secret> matrix_o = null;
  private ?secret mp.DAVector<secret> w;
  private ?secret mp.DAVector<secret> ew;
  public !everyone Player (?everyone mp.DNCChain<everyone> chain, ?everyone java.lang.String name) throws !everyone java.lang.IllegalArgumentException, !everyone java.security.NoSuchAlgorithmException, !everyone mp.MPException
  {
  }
  private !everyone ?everyone mp.DNCLink<everyone> computeLink(?everyone int k, ?everyone mp.DataField<everyone> data, ?everyone byte[]<everyone> prevChainingValue)
  {
  }
  private !everyone void buildLink(?everyone java.lang.String info, ?everyone mp.DataFieldAttribute<everyone> attr) throws !everyone java.lang.IllegalArgumentException, !everyone mp.MPException
  {
  }
  private ?secret int idnt = 0;
  public !everyone ?everyone void initProtocol() throws !everyone mp.MPException, !everyone java.lang.SecurityException, !everyone java.security.NoSuchAlgorithmException, !everyone java.lang.IllegalArgumentException, !everyone java.lang.IndexOutOfBoundsException, !everyone java.lang.ArithmeticException
  {
    ?secret mp.Digest<secret> C_p = null;
    mp.PHIntVector<secret> d = new mp.PHIntVector<secret>();
    mp.PHIntVector<secret> e = new mp.PHIntVector<secret>();
    ?secret mp.DABigInteger<secret> z_u = null;
    p = this.generatePermutation();
    ph = new mp.PHCrypto<secret>(2);
    ?secret mp.DABigInteger<secret> m = ph.getPublicParam();
    ?secret java.lang.String sha1 = "SHA1PRNG";
    z_u = null;
    while ((z_u.compareTo(m) >= 0) || (z_u.compareTo(mp.DABigInteger.<secret>ZERO()) <= 0)) {
                                                                                              z_u = null;
                                                                                            }
    matrix = new mp.PermutationMatrix<secret>(p, z_u);
    matrixCopy = matrix.cloneMatrix();
    C_p = matrix.getDigest();
    int s = DECKSIZE + 2;
    mp.BigIntVector<secret> delta = new mp.BigIntVector<secret>(s);
    mp.BigIntVector<secret> eps = new mp.BigIntVector<secret>(s);
    mp.PHInteger<secret> dsum = d.getPHI(0);
    for (int i = 1 ; i < s ; i++) {
                                    dsum = dsum.add(d.getPHI(i));
                                  }
    mp.DABigInteger<secret> dSumDecrypted = ph.decrypt(dsum);
  }
  private !secret ?secret byte[]<secret> generatePermutation()
  {
  }
  public !everyone void drawCard(?everyone int card) throws !everyone java.lang.IllegalArgumentException, !everyone mp.MPException, !everyone java.lang.SecurityException
  {
  }
  public !everyone void processCardDraw() throws !everyone java.lang.IllegalArgumentException, !everyone mp.MPException, !everyone java.lang.SecurityException
  {
  }
  public !everyone void processSelfCardDraw() throws !everyone mp.MPException, !everyone java.lang.SecurityException
  {
  }
}
Fetching type mp.Channel ...
Checking for ./mp/Channel.pi
Found ./mp/Channel.pi
Resolving import: import java.lang.*;
Resolving import: import java.io.*;
Resolving import: import mp.*;
Adding for name: mp.Channel
fetchPols: 
  ("channelP",PolicyExp () (PolicyLit () [Clause () (Actor () (ActorName () (Name () EName Nothing (Ident () "channel")))) []]),True)
Fetching type java.io.PrintStream ...
Checking for ./java/io/PrintStream.pi
Found ./java/io/PrintStream.pi
Resolving import: import java.lang.*;
Adding for name: java.io.PrintStream
Fetching type java.lang.String ...
Checking for ./java/lang/String.pi
Found ./java/lang/String.pi
Resolving import: import java.lang.*;
Resolving import: import java.lang.*;
Adding for name: java.lang.String
Fetching type java.lang.Character ...
Checking for ./java/lang/Character.pi
Found ./java/lang/Character.pi
Resolving import: import java.lang.*;
Resolving import: import java.lang.*;
Adding for name: java.lang.Character
Done fetching type: java.lang.Character
Done fetching type: java.lang.String
Done fetching type: java.io.PrintStream
Fetching type java.io.InputStream ...
Checking for ./java/io/InputStream.pi
Found ./java/io/InputStream.pi
Resolving import: import java.lang.*;
Adding for name: java.io.InputStream
Done fetching type: java.io.InputStream
Done fetching type: mp.Channel
lookupVar: mp.Channel.channel :: actor
   mPreTy: Just (TcType (TcRefT (TcClsRefT (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "Channel")) []))))
Fetching type mp.GameState ...
Checking for ./mp/GameState.pi
Found ./mp/GameState.pi
Resolving import: import java.lang.*;
Adding for name: mp.GameState
fetchLocks: [(Ident () "GameEnded",[Public (),Static (),Readonly ()],[],Nothing)]
fetchLocks: [(Ident () "GameRunning",[Public (),Static (),Readonly ()],[],Nothing)]
Done fetching type: mp.GameState
Solving constraints...
0
Constraints successfully solved!
lookupVar: mp.Channel.channel :: actor
   mPreTy: Just (TcType (TcRefT (TcClsRefT (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "Channel")) []))))
lookupVar: mp.Channel.channel :: actor
   mPreTy: Just (TcType (TcRefT (TcClsRefT (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "Channel")) []))))
Fetching type mp.TrustedDeclassifier ...
Checking for ./mp/TrustedDeclassifier.pi
Found ./mp/TrustedDeclassifier.pi
Resolving import: import java.lang.*;
Resolving import: import mp.*;
Renaming atom: Declassify
Checking for ./mp/DABigInteger.pi
Found ./mp/DABigInteger.pi
Checking for ./mp/DABigInteger.pi
Found ./mp/DABigInteger.pi
Checking for ./mp/Digest.pi
Found ./mp/Digest.pi
Checking for ./mp/Digest.pi
Found ./mp/Digest.pi
Checking for ./mp/PHIntVector.pi
Found ./mp/PHIntVector.pi
Checking for ./mp/PHIntVector.pi
Found ./mp/PHIntVector.pi
Checking for ./mp/CardVector.pi
Found ./mp/CardVector.pi
Checking for ./mp/CardVector.pi
Found ./mp/CardVector.pi
Checking for ./mp/BigIntVector.pi
Found ./mp/BigIntVector.pi
Checking for ./mp/BigIntVector.pi
Found ./mp/BigIntVector.pi
Adding for name: mp.TrustedDeclassifier
fetchPols: 
  ("trusted",PolicyExp () (PolicyLit () [Clause () (Actor () (ActorName () (Name () EName Nothing (Ident () "trustor")))) []]),True)
fetchLocks: [(Ident () "Declassify",[Public (),Static (),Final (),Reads () (ExpName () (Name () EName Nothing (Ident () "trusted")))],[],Nothing)]
fetchPols: 
  ("declasable",PolicyExp () (PolicyLit () [Clause () (Var () (Ident () "x")) [Atom () (Name () LName Nothing (Ident () "Declassify")) []]]),True)
Fetching type mp.DABigInteger ...
Checking for ./mp/DABigInteger.pi
Found ./mp/DABigInteger.pi
Resolving import: import java.lang.*;
Resolving import: import mp.*;
Checking for ./mp/DataFieldAttribute.pi
Found ./mp/DataFieldAttribute.pi
Checking for ./java/math.pi
Checking for /home/niklas/src/paragon/lib/java/math.pi
Checking for ./java/math.pi
Checking for ./java/math/BigInteger.pi
Found ./java/math/BigInteger.pi
Checking for ./java/math.pi
Checking for /home/niklas/src/paragon/lib/java/math.pi
Checking for ./java/math.pi
Checking for ./java/math/BigInteger.pi
Found ./java/math/BigInteger.pi
Checking for ./java/math.pi
Checking for /home/niklas/src/paragon/lib/java/math.pi
Checking for ./java/math.pi
Checking for ./java/math/BigInteger.pi
Found ./java/math/BigInteger.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IllegalArgumentException.pi
Found ./java/lang/IllegalArgumentException.pi
Checking for ./java/util.pi
Checking for /home/niklas/src/paragon/lib/java/util.pi
Checking for ./java/util.pi
Checking for ./java/util/Random.pi
Found ./java/util/Random.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IllegalArgumentException.pi
Found ./java/lang/IllegalArgumentException.pi
Checking for ./java/util.pi
Checking for /home/niklas/src/paragon/lib/java/util.pi
Checking for ./java/util.pi
Checking for ./java/util/Random.pi
Found ./java/util/Random.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/ArithmeticException.pi
Found ./java/lang/ArithmeticException.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/String.pi
Found ./java/lang/String.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/NumberFormatException.pi
Found ./java/lang/NumberFormatException.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IllegalArgumentException.pi
Found ./java/lang/IllegalArgumentException.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IllegalArgumentException.pi
Found ./java/lang/IllegalArgumentException.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IllegalArgumentException.pi
Found ./java/lang/IllegalArgumentException.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IllegalArgumentException.pi
Found ./java/lang/IllegalArgumentException.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IllegalArgumentException.pi
Found ./java/lang/IllegalArgumentException.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/ArithmeticException.pi
Found ./java/lang/ArithmeticException.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IllegalArgumentException.pi
Found ./java/lang/IllegalArgumentException.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/ArithmeticException.pi
Found ./java/lang/ArithmeticException.pi
Checking for ./java/util.pi
Checking for /home/niklas/src/paragon/lib/java/util.pi
Checking for ./java/util.pi
Checking for ./java/util/Random.pi
Found ./java/util/Random.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/ArithmeticException.pi
Found ./java/lang/ArithmeticException.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/String.pi
Found ./java/lang/String.pi
Fetching type mp.DataFieldAttribute ...
Checking for ./mp/DataFieldAttribute.pi
Found ./mp/DataFieldAttribute.pi
Resolving import: import java.lang.*;
Resolving import: import mp.*;
Adding for name: mp.DataFieldAttribute
Done fetching type: mp.DataFieldAttribute
Adding for name: mp.DABigInteger
Fetching type java.math.BigInteger ...
Checking for ./java/math/BigInteger.pi
Found ./java/math/BigInteger.pi
Resolving import: import java.lang.*;
Resolving import: import java.util.Random;
Checking for ./java/util/Random.pi
Found ./java/util/Random.pi
Resolving import: import java.math.*;
Checking for ./java/math.pi
Checking for /home/niklas/src/paragon/lib/java/math.pi
Checking for ./java/math.pi
Checking for ./java/math.pi
Checking for /home/niklas/src/paragon/lib/java/math.pi
Checking for ./java/math.pi
Checking for ./java/math.pi
Checking for /home/niklas/src/paragon/lib/java/math.pi
Checking for ./java/math.pi
Checking for ./java/math.pi
Checking for /home/niklas/src/paragon/lib/java/math.pi
Checking for ./java/math.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/ArithmeticException.pi
Found ./java/lang/ArithmeticException.pi
Checking for ./java/math.pi
Checking for /home/niklas/src/paragon/lib/java/math.pi
Checking for ./java/math.pi
Checking for ./java/math.pi
Checking for /home/niklas/src/paragon/lib/java/math.pi
Checking for ./java/math.pi
Checking for ./java/math.pi
Checking for /home/niklas/src/paragon/lib/java/math.pi
Checking for ./java/math.pi
Checking for ./java/math.pi
Checking for /home/niklas/src/paragon/lib/java/math.pi
Checking for ./java/math.pi
Checking for ./java/math.pi
Checking for /home/niklas/src/paragon/lib/java/math.pi
Checking for ./java/math.pi
Checking for ./java/math.pi
Checking for /home/niklas/src/paragon/lib/java/math.pi
Checking for ./java/math.pi
Checking for ./java/math.pi
Checking for /home/niklas/src/paragon/lib/java/math.pi
Checking for ./java/math.pi
Checking for ./java/math.pi
Checking for /home/niklas/src/paragon/lib/java/math.pi
Checking for ./java/math.pi
Checking for ./java/math.pi
Checking for /home/niklas/src/paragon/lib/java/math.pi
Checking for ./java/math.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/ArithmeticException.pi
Found ./java/lang/ArithmeticException.pi
Adding for name: java.math.BigInteger
Fetching type java.lang.ArithmeticException ...
Checking for ./java/lang/ArithmeticException.pi
Found ./java/lang/ArithmeticException.pi
Resolving import: import java.lang.*;
Resolving import: import java.lang.*;
Adding for name: java.lang.ArithmeticException
Done fetching type: java.lang.ArithmeticException
Fetching type java.util.Random ...
Checking for ./java/util/Random.pi
Found ./java/util/Random.pi
Resolving import: import java.lang.*;
Resolving import: import java.lang.IllegalArgumentException;
Checking for ./java/lang/IllegalArgumentException.pi
Found ./java/lang/IllegalArgumentException.pi
Resolving import: import java.util.*;
Adding for name: java.util.Random
Fetching type java.lang.IllegalArgumentException ...
Checking for ./java/lang/IllegalArgumentException.pi
Found ./java/lang/IllegalArgumentException.pi
Resolving import: import java.lang.*;
Resolving import: import java.lang.*;
Adding for name: java.lang.IllegalArgumentException
Done fetching type: java.lang.IllegalArgumentException
Done fetching type: java.util.Random
Fetching type java.lang.NumberFormatException ...
Checking for ./java/lang/NumberFormatException.pi
Found ./java/lang/NumberFormatException.pi
Resolving import: import java.lang.*;
Resolving import: import java.lang.*;
Adding for name: java.lang.NumberFormatException
Done fetching type: java.lang.NumberFormatException
Done fetching type: java.math.BigInteger
Done fetching type: mp.DABigInteger
Fetching type mp.Digest ...
Checking for ./mp/Digest.pi
Found ./mp/Digest.pi
Resolving import: import java.lang.*;
Resolving import: import mp.*;
Checking for ./mp/DataFieldAttribute.pi
Found ./mp/DataFieldAttribute.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/String.pi
Found ./java/lang/String.pi
Adding for name: mp.Digest
Done fetching type: mp.Digest
Fetching type mp.PHIntVector ...
Checking for ./mp/PHIntVector.pi
Found ./mp/PHIntVector.pi
Resolving import: import java.lang.*;
Resolving import: import mp.*;
Checking for ./java/util.pi
Checking for /home/niklas/src/paragon/lib/java/util.pi
Checking for ./java/util.pi
Checking for ./java/util/ArrayList.pi
Found ./java/util/ArrayList.pi
Checking for ./java/util/ArrayList.pi
Found ./java/util/ArrayList.pi
Checking for ./java/util.pi
Checking for /home/niklas/src/paragon/lib/java/util.pi
Checking for ./java/util.pi
Checking for ./java/util/ArrayList.pi
Found ./java/util/ArrayList.pi
Checking for ./mp/DataFieldAttribute.pi
Found ./mp/DataFieldAttribute.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/String.pi
Found ./java/lang/String.pi
Checking for ./mp/PHInteger.pi
Found ./mp/PHInteger.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IndexOutOfBoundsException.pi
Found ./java/lang/IndexOutOfBoundsException.pi
Fetching type java.util.ArrayList ...
Checking for ./java/util/ArrayList.pi
Found ./java/util/ArrayList.pi
Resolving import: import java.lang.*;
Adding for name: java.util.ArrayList
Fetching type java.lang.Object ...
Checking for ./java/lang/Object.pi
Found ./java/lang/Object.pi
Resolving import: import java.lang.*;
Adding for name: java.lang.Object
Done fetching type: java.lang.Object
Done fetching type: java.util.ArrayList
Adding for name: mp.PHIntVector
Fetching type mp.PHInteger ...
Checking for ./mp/PHInteger.pi
Found ./mp/PHInteger.pi
Resolving import: import java.lang.*;
Resolving import: import mp.*;
Checking for ./mp/DataFieldAttribute.pi
Found ./mp/DataFieldAttribute.pi
Checking for ./java/util.pi
Checking for /home/niklas/src/paragon/lib/java/util.pi
Checking for ./java/util.pi
Checking for ./java/util/ArrayList.pi
Found ./java/util/ArrayList.pi
Checking for ./java/util.pi
Checking for /home/niklas/src/paragon/lib/java/util.pi
Checking for ./java/util.pi
Checking for ./java/util/ArrayList.pi
Found ./java/util/ArrayList.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/String.pi
Found ./java/lang/String.pi
Checking for ./java/util.pi
Checking for /home/niklas/src/paragon/lib/java/util.pi
Checking for ./java/util.pi
Checking for ./java/util/ArrayList.pi
Found ./java/util/ArrayList.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IllegalArgumentException.pi
Found ./java/lang/IllegalArgumentException.pi
Adding for name: mp.PHInteger
Done fetching type: mp.PHInteger
Fetching type java.lang.IndexOutOfBoundsException ...
Checking for ./java/lang/IndexOutOfBoundsException.pi
Found ./java/lang/IndexOutOfBoundsException.pi
Resolving import: import java.lang.*;
Resolving import: import java.lang.*;
Adding for name: java.lang.IndexOutOfBoundsException
Done fetching type: java.lang.IndexOutOfBoundsException
Done fetching type: mp.PHIntVector
Fetching type mp.CardVector ...
Checking for ./mp/CardVector.pi
Found ./mp/CardVector.pi
Resolving import: import java.lang.*;
Resolving import: import mp.*;
Checking for ./mp/DataFieldAttribute.pi
Found ./mp/DataFieldAttribute.pi
Checking for ./mp/BigIntVector.pi
Found ./mp/BigIntVector.pi
Checking for ./mp/BigIntVector.pi
Found ./mp/BigIntVector.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IllegalArgumentException.pi
Found ./java/lang/IllegalArgumentException.pi
Checking for ./mp/DABigInteger.pi
Found ./mp/DABigInteger.pi
Checking for ./mp/DABigInteger.pi
Found ./mp/DABigInteger.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IllegalArgumentException.pi
Found ./java/lang/IllegalArgumentException.pi
Checking for ./java/security.pi
Checking for /home/niklas/src/paragon/lib/java/security.pi
Checking for ./java/security.pi
Checking for ./java/security/NoSuchAlgorithmException.pi
Found ./java/security/NoSuchAlgorithmException.pi
Checking for ./mp/MPException.pi
Found ./mp/MPException.pi
Checking for ./mp/BigIntVector.pi
Found ./mp/BigIntVector.pi
Checking for ./mp/DABigInteger.pi
Found ./mp/DABigInteger.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IndexOutOfBoundsException.pi
Found ./java/lang/IndexOutOfBoundsException.pi
Checking for ./mp/PermutationMatrix.pi
Found ./mp/PermutationMatrix.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IllegalArgumentException.pi
Found ./java/lang/IllegalArgumentException.pi
Checking for ./mp/MPException.pi
Found ./mp/MPException.pi
Checking for ./mp/DABigInteger.pi
Found ./mp/DABigInteger.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IllegalArgumentException.pi
Found ./java/lang/IllegalArgumentException.pi
Checking for ./mp/MPException.pi
Found ./mp/MPException.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/String.pi
Found ./java/lang/String.pi
Adding for name: mp.CardVector
Fetching type mp.BigIntVector ...
Checking for ./mp/BigIntVector.pi
Found ./mp/BigIntVector.pi
Resolving import: import java.lang.*;
Resolving import: import mp.*;
Checking for ./java/util.pi
Checking for /home/niklas/src/paragon/lib/java/util.pi
Checking for ./java/util.pi
Checking for ./java/util/ArrayList.pi
Found ./java/util/ArrayList.pi
Checking for ./java/util/ArrayList.pi
Found ./java/util/ArrayList.pi
Checking for ./java/util.pi
Checking for /home/niklas/src/paragon/lib/java/util.pi
Checking for ./java/util.pi
Checking for ./java/util/ArrayList.pi
Found ./java/util/ArrayList.pi
Checking for ./mp/DataFieldAttribute.pi
Found ./mp/DataFieldAttribute.pi
Checking for ./mp/DABigInteger.pi
Found ./mp/DABigInteger.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IndexOutOfBoundsException.pi
Found ./java/lang/IndexOutOfBoundsException.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/String.pi
Found ./java/lang/String.pi
Adding for name: mp.BigIntVector
Done fetching type: mp.BigIntVector
Fetching type mp.PermutationMatrix ...
Checking for ./mp/PermutationMatrix.pi
Found ./mp/PermutationMatrix.pi
Resolving import: import java.lang.*;
Resolving import: import mp.*;
Checking for ./java/util.pi
Checking for /home/niklas/src/paragon/lib/java/util.pi
Checking for ./java/util.pi
Checking for ./java/util/ArrayList.pi
Found ./java/util/ArrayList.pi
Checking for ./java/util.pi
Checking for /home/niklas/src/paragon/lib/java/util.pi
Checking for ./java/util.pi
Checking for ./java/util/ArrayList.pi
Found ./java/util/ArrayList.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IllegalArgumentException.pi
Found ./java/lang/IllegalArgumentException.pi
Checking for ./mp/DABigInteger.pi
Found ./mp/DABigInteger.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IllegalArgumentException.pi
Found ./java/lang/IllegalArgumentException.pi
Checking for ./java/security.pi
Checking for /home/niklas/src/paragon/lib/java/security.pi
Checking for ./java/security.pi
Checking for ./java/security/NoSuchAlgorithmException.pi
Found ./java/security/NoSuchAlgorithmException.pi
Checking for ./mp/MPException.pi
Found ./mp/MPException.pi
Checking for ./mp/DABigInteger.pi
Found ./mp/DABigInteger.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IllegalArgumentException.pi
Found ./java/lang/IllegalArgumentException.pi
Checking for ./mp/MPException.pi
Found ./mp/MPException.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/String.pi
Found ./java/lang/String.pi
Checking for ./mp/Digest.pi
Found ./mp/Digest.pi
Checking for ./mp/MPException.pi
Found ./mp/MPException.pi
Checking for ./mp/DABigInteger.pi
Found ./mp/DABigInteger.pi
Checking for ./mp/MPException.pi
Found ./mp/MPException.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IllegalArgumentException.pi
Found ./java/lang/IllegalArgumentException.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IndexOutOfBoundsException.pi
Found ./java/lang/IndexOutOfBoundsException.pi
Checking for ./java/util.pi
Checking for /home/niklas/src/paragon/lib/java/util.pi
Checking for ./java/util.pi
Checking for ./java/util/ArrayList.pi
Found ./java/util/ArrayList.pi
Adding for name: mp.PermutationMatrix
Fetching type mp.MPException ...
Checking for ./mp/MPException.pi
Found ./mp/MPException.pi
Resolving import: import java.lang.*;
Resolving import: import mp.*;
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/Exception.pi
Found ./java/lang/Exception.pi
Checking for ./java/lang/Exception.pi
Found ./java/lang/Exception.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/Exception.pi
Found ./java/lang/Exception.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/String.pi
Found ./java/lang/String.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/Throwable.pi
Found ./java/lang/Throwable.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/String.pi
Found ./java/lang/String.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/String.pi
Found ./java/lang/String.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/Throwable.pi
Found ./java/lang/Throwable.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/Throwable.pi
Found ./java/lang/Throwable.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/String.pi
Found ./java/lang/String.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/String.pi
Found ./java/lang/String.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/Throwable.pi
Found ./java/lang/Throwable.pi
Fetching type java.lang.Exception ...
Checking for ./java/lang/Exception.pi
Found ./java/lang/Exception.pi
Resolving import: import java.lang.*;
Resolving import: import java.lang.*;
Adding for name: java.lang.Exception
Done fetching type: java.lang.Exception
Adding for name: mp.MPException
Fetching type java.lang.Throwable ...
Checking for ./java/lang/Throwable.pi
Found ./java/lang/Throwable.pi
Resolving import: import java.lang.*;
Adding for name: java.lang.Throwable
Done fetching type: java.lang.Throwable
Done fetching type: mp.MPException
Fetching type java.security.NoSuchAlgorithmException ...
Checking for ./java/security/NoSuchAlgorithmException.pi
Found ./java/security/NoSuchAlgorithmException.pi
Resolving import: import java.lang.*;
Resolving import: import java.lang.Exception;
Checking for ./java/lang/Exception.pi
Found ./java/lang/Exception.pi
Resolving import: import java.lang.String;
Checking for ./java/lang/String.pi
Found ./java/lang/String.pi
Resolving import: import java.security.*;
Checking for ./java/lang/Exception.pi
Found ./java/lang/Exception.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/String.pi
Found ./java/lang/String.pi
Adding for name: java.security.NoSuchAlgorithmException
Done fetching type: java.security.NoSuchAlgorithmException
Done fetching type: mp.PermutationMatrix
Done fetching type: mp.CardVector
Done fetching type: mp.TrustedDeclassifier
Solving constraints...
0
Constraints successfully solved!
lookupVar: mp.Channel.channel :: actor
   mPreTy: Just (TcType (TcRefT (TcClsRefT (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "Channel")) []))))
Var: atEndGame (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []]]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: declass (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Solving constraints...
0
Constraints successfully solved!
Var: atEndGame (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []]]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: declass (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
lookupVar: mp.Channel.channelP :: policy
   mPreTy: Just (TcType (TcRefT (TcClsRefT (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "Channel")) []))))
Solving constraints...
0
Constraints successfully solved!
lookupVar: mp.Channel.channelP :: policy
   mPreTy: Just (TcType (TcRefT (TcClsRefT (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "Channel")) []))))
typeCheckSignatures start
Type evaluated to: TcPrimT (IntT ())
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Type evaluated to: TcPrimT (IntT ())
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Fetching type mp.PHCrypto ...
Checking for ./mp/PHCrypto.pi
Found ./mp/PHCrypto.pi
Resolving import: import java.lang.*;
Resolving import: import mp.*;
Checking for ./mp/DABigInteger.pi
Found ./mp/DABigInteger.pi
Checking for ./mp/DABigInteger.pi
Found ./mp/DABigInteger.pi
Checking for ./mp/DABigInteger.pi
Found ./mp/DABigInteger.pi
Checking for ./mp/DABigInteger.pi
Found ./mp/DABigInteger.pi
Checking for ./mp/DABigInteger.pi
Found ./mp/DABigInteger.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/String.pi
Found ./java/lang/String.pi
Checking for ./java/security.pi
Checking for /home/niklas/src/paragon/lib/java/security.pi
Checking for ./java/security.pi
Checking for ./java/security/NoSuchAlgorithmException.pi
Found ./java/security/NoSuchAlgorithmException.pi
Checking for ./mp/MPException.pi
Found ./mp/MPException.pi
Checking for ./mp/DABigInteger.pi
Found ./mp/DABigInteger.pi
Checking for ./java/security.pi
Checking for /home/niklas/src/paragon/lib/java/security.pi
Checking for ./java/security.pi
Checking for ./java/security/NoSuchAlgorithmException.pi
Found ./java/security/NoSuchAlgorithmException.pi
Checking for ./mp/PHInteger.pi
Found ./mp/PHInteger.pi
Checking for ./mp/DABigInteger.pi
Found ./mp/DABigInteger.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IllegalArgumentException.pi
Found ./java/lang/IllegalArgumentException.pi
Checking for ./mp/MPException.pi
Found ./mp/MPException.pi
Checking for ./mp/EncryptedCardVector.pi
Found ./mp/EncryptedCardVector.pi
Checking for ./mp/CardVector.pi
Found ./mp/CardVector.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IllegalArgumentException.pi
Found ./java/lang/IllegalArgumentException.pi
Checking for ./mp/MPException.pi
Found ./mp/MPException.pi
Checking for ./mp/DABigInteger.pi
Found ./mp/DABigInteger.pi
Checking for ./mp/PHInteger.pi
Found ./mp/PHInteger.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IllegalArgumentException.pi
Found ./java/lang/IllegalArgumentException.pi
Checking for ./mp/MPException.pi
Found ./mp/MPException.pi
Adding for name: mp.PHCrypto
Fetching type mp.EncryptedCardVector ...
Checking for ./mp/EncryptedCardVector.pi
Found ./mp/EncryptedCardVector.pi
Resolving import: import java.lang.*;
Resolving import: import mp.*;
Checking for ./mp/DataFieldAttribute.pi
Found ./mp/DataFieldAttribute.pi
Checking for ./mp/PHIntVector.pi
Found ./mp/PHIntVector.pi
Checking for ./mp/PHIntVector.pi
Found ./mp/PHIntVector.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IllegalArgumentException.pi
Found ./java/lang/IllegalArgumentException.pi
Adding for name: mp.EncryptedCardVector
Done fetching type: mp.EncryptedCardVector
Done fetching type: mp.PHCrypto
Type evaluated to: TcRefT (TcClsRefT (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "PHCrypto")) [TcActualPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))]))
Var: secret (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Type evaluated to: TcRefT (TcClsRefT (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "PHCrypto")) [TcActualPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Type evaluated to: TcRefT (TcArrayT (TcPrimT (BooleanT ())) (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []])))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Type evaluated to: TcRefT (TcArrayT (TcPrimT (IntT ())) (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []]])))
Var: atEndGame (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []]]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Type evaluated to: TcPrimT (IntT ())
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Type evaluated to: TcRefT (TcClsRefT (TcClassT (Name () TName (Just (Name () PName (Just (Name () PName Nothing (Ident () "java"))) (Ident () "lang"))) (Ident () "String")) []))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Type evaluated to: TcPrimT (IntT ())
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Type evaluated to: TcPrimT (IntT ())
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Type evaluated to: TcPrimT (IntT ())
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Fetching type mp.DNCChain ...
Checking for ./mp/DNCChain.pi
Found ./mp/DNCChain.pi
Resolving import: import java.lang.*;
Resolving import: import mp.*;
Checking for ./java/util.pi
Checking for /home/niklas/src/paragon/lib/java/util.pi
Checking for ./java/util.pi
Checking for ./java/util/ArrayList.pi
Found ./java/util/ArrayList.pi
Checking for ./mp/SerializeWriteHelper.pi
Found ./mp/SerializeWriteHelper.pi
Checking for ./mp/SerializeWriteHelper.pi
Found ./mp/SerializeWriteHelper.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IllegalArgumentException.pi
Found ./java/lang/IllegalArgumentException.pi
Checking for ./mp/DNCLink.pi
Found ./mp/DNCLink.pi
Checking for ./mp/DNCLink.pi
Found ./mp/DNCLink.pi
Checking for ./mp/DNCLink.pi
Found ./mp/DNCLink.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IndexOutOfBoundsException.pi
Found ./java/lang/IndexOutOfBoundsException.pi
Adding for name: mp.DNCChain
Fetching type mp.SerializeWriteHelper ...
Checking for ./mp/SerializeWriteHelper.pi
Found ./mp/SerializeWriteHelper.pi
Resolving import: import java.lang.*;
Resolving import: import mp.*;
Checking for ./java/io.pi
Checking for /home/niklas/src/paragon/lib/java/io.pi
Checking for ./java/io.pi
Checking for ./java/io/PrintStream.pi
Found ./java/io/PrintStream.pi
Checking for ./java/io.pi
Checking for /home/niklas/src/paragon/lib/java/io.pi
Checking for ./java/io.pi
Checking for ./java/io/PrintStream.pi
Found ./java/io/PrintStream.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/IllegalArgumentException.pi
Found ./java/lang/IllegalArgumentException.pi
Adding for name: mp.SerializeWriteHelper
Done fetching type: mp.SerializeWriteHelper
Fetching type mp.DNCLink ...
Checking for ./mp/DNCLink.pi
Found ./mp/DNCLink.pi
Resolving import: import java.lang.*;
Resolving import: import mp.*;
Checking for ./mp/DataField.pi
Found ./mp/DataField.pi
Checking for ./mp/DataField.pi
Found ./mp/DataField.pi
Checking for ./mp/DataField.pi
Found ./mp/DataField.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/String.pi
Found ./java/lang/String.pi
Adding for name: mp.DNCLink
Fetching type mp.DataField ...
Checking for ./mp/DataField.pi
Found ./mp/DataField.pi
Resolving import: import java.lang.*;
Resolving import: import mp.*;
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/String.pi
Found ./java/lang/String.pi
Checking for ./mp/DataFieldAttribute.pi
Found ./mp/DataFieldAttribute.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/String.pi
Found ./java/lang/String.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/String.pi
Found ./java/lang/String.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/String.pi
Found ./java/lang/String.pi
Checking for ./mp/DataFieldAttribute.pi
Found ./mp/DataFieldAttribute.pi
Checking for ./mp/DataFieldAttribute.pi
Found ./mp/DataFieldAttribute.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/String.pi
Found ./java/lang/String.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/String.pi
Found ./java/lang/String.pi
Checking for ./java/lang.pi
Checking for /home/niklas/src/paragon/lib/java/lang.pi
Checking for ./java/lang.pi
Checking for ./java/lang/String.pi
Found ./java/lang/String.pi
Adding for name: mp.DataField
Done fetching type: mp.DataField
Done fetching type: mp.DNCLink
Done fetching type: mp.DNCChain
Type evaluated to: TcRefT (TcClsRefT (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "DNCChain")) [TcActualPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Type evaluated to: TcRefT (TcClsRefT (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "DABigInteger")) [TcActualPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Fetching type java.security.KeyPair ...
Checking for ./java/security/KeyPair.pi
Found ./java/security/KeyPair.pi
Resolving import: import java.lang.*;
Resolving import: import java.security.PublicKey;
Checking for ./java/security/PublicKey.pi
Found ./java/security/PublicKey.pi
Resolving import: import java.security.PrivateKey;
Checking for ./java/security/PrivateKey.pi
Found ./java/security/PrivateKey.pi
Resolving import: import java.security.*;
Adding for name: java.security.KeyPair
Fetching type java.security.PublicKey ...
Checking for ./java/security/PublicKey.pi
Found ./java/security/PublicKey.pi
Resolving import: import java.lang.*;
Resolving import: import java.security.*;
Fetching type java.security.PrivateKey ...
Checking for ./java/security/PrivateKey.pi
Found ./java/security/PrivateKey.pi
Resolving import: import java.lang.*;
Resolving import: import java.security.*;
Done fetching type: java.security.KeyPair
Type evaluated to: TcRefT (TcClsRefT (TcClassT (Name () TName (Just (Name () PName (Just (Name () PName Nothing (Ident () "java"))) (Ident () "security"))) (Ident () "KeyPair")) [TcActualPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []])),TcActualPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Type evaluated to: TcRefT (TcArrayT (TcPrimT (ByteT ())) (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])))
Var: secret (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Type evaluated to: TcRefT (TcArrayT (TcPrimT (ByteT ())) (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []])))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Type evaluated to: TcRefT (TcClsRefT (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "PermutationMatrix")) [TcActualPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))]))
Var: secret (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Type evaluated to: TcRefT (TcClsRefT (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "PermutationMatrix")) [TcActualPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))]))
Var: secret (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Fetching type mp.PHEPermutationMatrix ...
Checking for ./mp/PHEPermutationMatrix.pi
Found ./mp/PHEPermutationMatrix.pi
Resolving import: import java.lang.*;
Resolving import: import mp.*;
Adding for name: mp.PHEPermutationMatrix
Done fetching type: mp.PHEPermutationMatrix
Type evaluated to: TcRefT (TcClsRefT (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "PHEPermutationMatrix")) [TcActualPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))]))
Var: secret (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Fetching type mp.DAVector ...
Checking for ./mp/DAVector.pi
Found ./mp/DAVector.pi
Resolving import: import java.lang.*;
Resolving import: import mp.*;
Checking for ./java/util.pi
Checking for /home/niklas/src/paragon/lib/java/util.pi
Checking for ./java/util.pi
Checking for ./java/util/ArrayList.pi
Found ./java/util/ArrayList.pi
Checking for ./java/util/ArrayList.pi
Found ./java/util/ArrayList.pi
Checking for ./java/util.pi
Checking for /home/niklas/src/paragon/lib/java/util.pi
Checking for ./java/util.pi
Checking for ./java/util/ArrayList.pi
Found ./java/util/ArrayList.pi
Checking for ./mp/DataFieldAttribute.pi
Found ./mp/DataFieldAttribute.pi
Adding for name: mp.DAVector
Done fetching type: mp.DAVector
Type evaluated to: TcRefT (TcClsRefT (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "DAVector")) [TcActualPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))]))
Var: secret (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Type evaluated to: TcRefT (TcClsRefT (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "DAVector")) [TcActualPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))]))
Var: secret (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Method computeLink has wPol: TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Method buildLink has wPol: TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]
Type evaluated to: TcPrimT (IntT ())
Var: secret (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Fetching type java.lang.SecurityException ...
Checking for ./java/lang/SecurityException.pi
Found ./java/lang/SecurityException.pi
Resolving import: import java.lang.*;
Adding for name: java.lang.SecurityException
Done fetching type: java.lang.SecurityException
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Method initProtocol has wPol: TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]
Var: secret (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: secret (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Method generatePermutation has wPol: TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Method drawCard has wPol: TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Method processCardDraw has wPol: TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: everyone (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Method processSelfCardDraw has wPol: TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]
lookupVar: mp.Channel.channel :: actor
   mPreTy: Just (TcType (TcRefT (TcClsRefT (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "Channel")) []))))
Solving constraints...
0
Constraints successfully solved!
lookupVar: mp.Channel.channel :: actor
   mPreTy: Just (TcType (TcRefT (TcClsRefT (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "Channel")) []))))
Solving constraints...
0
Constraints successfully solved!
Var: atEndGame (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []]]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Var: declass (TcPolicyPolT (KnownPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))),RealPolicy (TcPolicy [TcClause (TcVar "x") []]))
Solving constraints...
0
Constraints successfully solved!
lookupVar: mp.Channel.channelP :: policy
   mPreTy: Just (TcType (TcRefT (TcClsRefT (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "Channel")) []))))
Solving constraints...
0
Constraints successfully solved!
Solving constraints...
0
Constraints successfully solved!
Solving constraints...
0
Constraints successfully solved!
Solving constraints...
0
Constraints successfully solved!
Solving constraints...
0
Constraints successfully solved!
Solving constraints...
0
Constraints successfully solved!
Solving constraints...
0
Constraints successfully solved!
Solving constraints...
0
Constraints successfully solved!
Solving constraints...
0
Constraints successfully solved!
lookupMethod: (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "DABigInteger")),Ident () "ZERO",[])
{ ([policy q],[],False) -->
    MSig {
      mRetType:  mp.DABigInteger<q>
      mRetPol:  q RealPolicy (TcRigidVar False "q")
      mPars:  []
      mParBounds:  []
    }
}
findBestMethod: 
  Candidates: 
    ([policy q],[],False)
  Argument types: 
    []
isApplicable: (False,[],[])
     .... []
Best method done
Solving constraints...
0
Constraints successfully solved!
Solving constraints...
0
Constraints successfully solved!
Solving constraints...
0
Constraints successfully solved!
Type-checking method private !everyone ?everyone mp.DNCLink<everyone> computeLink(?everyone int k, ?everyone mp.DataField<everyone> data, ?everyone byte[]<everyone> prevChainingValue)
;
pRet: RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []])
Solving constraints...
0
Constraints successfully solved!
Type-checking method private !everyone void buildLink(?everyone java.lang.String info, ?everyone mp.DataFieldAttribute<everyone> attr) throws !everyone java.lang.IllegalArgumentException, !everyone mp.MPException
;
pRet: RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []])
Solving constraints...
0
Constraints successfully solved!
Solving constraints...
0
Constraints successfully solved!
Type-checking method public !everyone ?everyone void initProtocol() throws !everyone mp.MPException, !everyone java.lang.SecurityException, !everyone java.security.NoSuchAlgorithmException, !everyone java.lang.IllegalArgumentException, !everyone java.lang.IndexOutOfBoundsException, !everyone java.lang.ArithmeticException
;
pRet: RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []])

####    C_p = null    ####


####    d = new mp.PHIntVector<secret>()    ####



######## Looking up constructor! ######## 

typ: mp.PHIntVector<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
cMap: 
{ ([],[],False) -->
    CSig {
      cPars:  []
      cParBounds:  []
    }
}
findBestMethod: 
  Candidates: 
    ([],[],False)
  Argument types: 
    []
isApplicable: (False,[],[])
     .... []
Best method done

####    e = new mp.PHIntVector<secret>()    ####



######## Looking up constructor! ######## 

typ: mp.PHIntVector<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
cMap: 
{ ([],[],False) -->
    CSig {
      cPars:  []
      cParBounds:  []
    }
}
findBestMethod: 
  Candidates: 
    ([],[],False)
  Argument types: 
    []
isApplicable: (False,[],[])
     .... []
Best method done

####    z_u = null    ####


##   p = this.generatePermutation()    ##

Var: p (TcType (TcRefT (TcArrayT (TcPrimT (ByteT ())) (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])))),RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))
findBestMethod: 
  Candidates: 
    ([],[],False)
  Argument types: 
    []
isApplicable: (False,[],[])
     .... []
Best method done
Done with assignment

##   ph = new mp.PHCrypto<secret>(2)    ##

Var: ph (TcInstance (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "PHCrypto")) [TcActualPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))]) [],RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))


######## Looking up constructor! ######## 

typ: mp.PHCrypto<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
cMap: 
{ ([],[int],False) -->
    CSig {
      cPars:  [n]
      cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
    }
}
findBestMethod: 
  Candidates: 
    ([],[int],False)
  Argument types: 
    [int]
isApplicable: (False,["int"],["int"])
     .... []
Best method done
Done with assignment

####    m = ph.getPublicParam()    ####

Var: ph (TcInstance (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "PHCrypto")) [TcActualPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))]) [],RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))
TSig {
  tType:  mp.PHCrypto
  tSupers: 
  tImpls: 
  bools:  [True,False]
  tMembers: 
  TypeMap {
    fields =>
      { BITLENGTH -->
          VSig {
            varType:  int
            varPol:  {'x:}
            bools:  [False,False,True]
          }
        m -->
          VSig {
            varType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,True]
          }
        nlength -->
          VSig {
            varType:  int
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,False]
          }
        p -->
          VSig {
            varType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,True]
          }
        q -->
          VSig {
            varType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,True]
          }
        rp -->
          VSig {
            varType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,False]
          }
        rq -->
          VSig {
            varType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,False]
          }
        sha1 -->
          VSig {
            varType:  java.lang.String
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,False]
          }
      }
    methods =>
      { decrypt -->
          { ([],[mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [encr]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        encrypt -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>,int],False) -->
              MSig {
                mRetType:  mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [_a,_n]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        encryptCardVector -->
          { ([],[mp.CardVector<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>,int],False) -->
              MSig {
                mRetType:  mp.EncryptedCardVector<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [w,n]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        generateR -->
          { ([],[],False) -->
              MSig {
                mRetType:  void
                mRetPol:  {'x:} RealPolicy (TcPolicy [TcClause (TcVar "x") []])
                mPars:  []
                mParBounds:  []
              }
          }
        getPublicParam -->
          { ([],[],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
      }
    constrs =>
      { ([],[int],False) -->
          CSig {
            cPars:  [n]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
      }
    locks =>{}
    policies =>{}
    actors =>{}
    typemethods =>{}
    types =>{}
    packages =>{}
  }
}
lookupMethod: (Just (Name () EName Nothing (Ident () "ph")),Ident () "getPublicParam",[])
Var: ph (TcInstance (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "PHCrypto")) [TcActualPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))]) [],RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))
TSig {
  tType:  mp.PHCrypto
  tSupers: 
  tImpls: 
  bools:  [True,False]
  tMembers: 
  TypeMap {
    fields =>
      { BITLENGTH -->
          VSig {
            varType:  int
            varPol:  {'x:}
            bools:  [False,False,True]
          }
        m -->
          VSig {
            varType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,True]
          }
        nlength -->
          VSig {
            varType:  int
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,False]
          }
        p -->
          VSig {
            varType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,True]
          }
        q -->
          VSig {
            varType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,True]
          }
        rp -->
          VSig {
            varType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,False]
          }
        rq -->
          VSig {
            varType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,False]
          }
        sha1 -->
          VSig {
            varType:  java.lang.String
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,False]
          }
      }
    methods =>
      { decrypt -->
          { ([],[mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [encr]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        encrypt -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>,int],False) -->
              MSig {
                mRetType:  mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [_a,_n]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        encryptCardVector -->
          { ([],[mp.CardVector<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>,int],False) -->
              MSig {
                mRetType:  mp.EncryptedCardVector<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [w,n]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        generateR -->
          { ([],[],False) -->
              MSig {
                mRetType:  void
                mRetPol:  {'x:} RealPolicy (TcPolicy [TcClause (TcVar "x") []])
                mPars:  []
                mParBounds:  []
              }
          }
        getPublicParam -->
          { ([],[],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
      }
    constrs =>
      { ([],[int],False) -->
          CSig {
            cPars:  [n]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
      }
    locks =>{}
    policies =>{}
    actors =>{}
    typemethods =>{}
    types =>{}
    packages =>{}
  }
}
{ ([],[],False) -->
    MSig {
      mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
      mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
      mPars:  []
      mParBounds:  []
    }
}
findBestMethod: 
  Candidates: 
    ([],[],False)
  Argument types: 
    []
isApplicable: (False,[],[])
     .... []
Best method done
msig: MSig {
  mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
  mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
  mPars:  []
  mParBounds:  []
}

####    sha1 = "SHA1PRNG"    ####


##   z_u = null    ##

%%% z_u is a variable!
mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
Done with assignment
%%% z_u is a variable!
mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
TSig {
  tType:  mp.DABigInteger
  tSupers: 
  tImpls:  mp.DataFieldAttribute<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
  bools:  [True,False]
  tMembers: 
  TypeMap {
    fields =>
      { value -->
          VSig {
            varType:  java.math.BigInteger
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,True]
          }
      }
    methods =>
      { ZERO -->
          { ([policy q],[],False) -->
              MSig {
                mRetType:  mp.DABigInteger<q>
                mRetPol:  q RealPolicy (TcRigidVar False "q")
                mPars:  []
                mParBounds:  []
              }
          }
        add -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [that]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        bitLength -->
          { ([],[],False) -->
              MSig {
                mRetType:  int
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        byteLength -->
          { ([],[],False) -->
              MSig {
                mRetType:  int
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        compareTo -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  int
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [that]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        getValue -->
          { ([],[],False) -->
              MSig {
                mRetType:  java.math.BigInteger
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        mod -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [that]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        modInverse -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [that]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        multiply -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [that]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        probablePrime -->
          { ([policy p],[int,java.util.Random<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [bitLength,rnd]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        subtract -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [that]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        toByteArray -->
          { ([],[],False) -->
              MSig {
                mRetType:  byte[]<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        toString -->
          { ([],[],False) -->
              MSig {
                mRetType:  java.lang.String
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
      }
    constrs =>
      { ([],[int,int,java.util.Random<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
          CSig {
            cPars:  [bitLength,certainty,rnd]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
        ([],[int,java.util.Random<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
          CSig {
            cPars:  [numBits,rnd]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
        ([],[java.lang.String],False) -->
          CSig {
            cPars:  [val]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
        ([],[java.math.BigInteger],False) -->
          CSig {
            cPars:  [val]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
      }
    locks =>{}
    policies =>{}
    actors =>{}
    typemethods =>{}
    types =>{}
    packages =>{}
  }
}
%%% m is a variable!
mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
lookupMethod: (Just (Name () EName Nothing (Ident () "z_u")),Ident () "compareTo",[TcRefT (TcClsRefT (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "DABigInteger")) [TcActualPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))]))])
%%% z_u is a variable!
mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
TSig {
  tType:  mp.DABigInteger
  tSupers: 
  tImpls:  mp.DataFieldAttribute<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
  bools:  [True,False]
  tMembers: 
  TypeMap {
    fields =>
      { value -->
          VSig {
            varType:  java.math.BigInteger
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,True]
          }
      }
    methods =>
      { ZERO -->
          { ([policy q],[],False) -->
              MSig {
                mRetType:  mp.DABigInteger<q>
                mRetPol:  q RealPolicy (TcRigidVar False "q")
                mPars:  []
                mParBounds:  []
              }
          }
        add -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [that]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        bitLength -->
          { ([],[],False) -->
              MSig {
                mRetType:  int
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        byteLength -->
          { ([],[],False) -->
              MSig {
                mRetType:  int
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        compareTo -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  int
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [that]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        getValue -->
          { ([],[],False) -->
              MSig {
                mRetType:  java.math.BigInteger
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        mod -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [that]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        modInverse -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [that]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        multiply -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [that]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        probablePrime -->
          { ([policy p],[int,java.util.Random<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [bitLength,rnd]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        subtract -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [that]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        toByteArray -->
          { ([],[],False) -->
              MSig {
                mRetType:  byte[]<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        toString -->
          { ([],[],False) -->
              MSig {
                mRetType:  java.lang.String
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
      }
    constrs =>
      { ([],[int,int,java.util.Random<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
          CSig {
            cPars:  [bitLength,certainty,rnd]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
        ([],[int,java.util.Random<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
          CSig {
            cPars:  [numBits,rnd]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
        ([],[java.lang.String],False) -->
          CSig {
            cPars:  [val]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
        ([],[java.math.BigInteger],False) -->
          CSig {
            cPars:  [val]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
      }
    locks =>{}
    policies =>{}
    actors =>{}
    typemethods =>{}
    types =>{}
    packages =>{}
  }
}
{ ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
    MSig {
      mRetType:  int
      mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
      mPars:  [that]
      mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
    }
}
findBestMethod: 
  Candidates: 
    ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False)
  Argument types: 
    [mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>]
isApplicable: (False,["mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>"],["mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>"])
     .... [[{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]]
Best method done
msig: MSig {
  mRetType:  int
  mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
  mPars:  [that]
  mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
}
%%% z_u is a variable!
mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
TSig {
  tType:  mp.DABigInteger
  tSupers: 
  tImpls:  mp.DataFieldAttribute<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
  bools:  [True,False]
  tMembers: 
  TypeMap {
    fields =>
      { value -->
          VSig {
            varType:  java.math.BigInteger
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,True]
          }
      }
    methods =>
      { ZERO -->
          { ([policy q],[],False) -->
              MSig {
                mRetType:  mp.DABigInteger<q>
                mRetPol:  q RealPolicy (TcRigidVar False "q")
                mPars:  []
                mParBounds:  []
              }
          }
        add -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [that]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        bitLength -->
          { ([],[],False) -->
              MSig {
                mRetType:  int
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        byteLength -->
          { ([],[],False) -->
              MSig {
                mRetType:  int
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        compareTo -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  int
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [that]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        getValue -->
          { ([],[],False) -->
              MSig {
                mRetType:  java.math.BigInteger
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        mod -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [that]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        modInverse -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [that]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        multiply -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [that]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        probablePrime -->
          { ([policy p],[int,java.util.Random<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [bitLength,rnd]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        subtract -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [that]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        toByteArray -->
          { ([],[],False) -->
              MSig {
                mRetType:  byte[]<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        toString -->
          { ([],[],False) -->
              MSig {
                mRetType:  java.lang.String
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
      }
    constrs =>
      { ([],[int,int,java.util.Random<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
          CSig {
            cPars:  [bitLength,certainty,rnd]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
        ([],[int,java.util.Random<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
          CSig {
            cPars:  [numBits,rnd]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
        ([],[java.lang.String],False) -->
          CSig {
            cPars:  [val]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
        ([],[java.math.BigInteger],False) -->
          CSig {
            cPars:  [val]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
      }
    locks =>{}
    policies =>{}
    actors =>{}
    typemethods =>{}
    types =>{}
    packages =>{}
  }
}
lookupMethod: (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "DABigInteger")),Ident () "ZERO",[])
{ ([policy q],[],False) -->
    MSig {
      mRetType:  mp.DABigInteger<q>
      mRetPol:  q RealPolicy (TcRigidVar False "q")
      mPars:  []
      mParBounds:  []
    }
}
findBestMethod: 
  Candidates: 
    ([policy q],[],False)
  Argument types: 
    []
isApplicable: (False,[],[])
     .... []
Best method done
lookupMethod: (Just (Name () EName Nothing (Ident () "z_u")),Ident () "compareTo",[TcRefT (TcClsRefT (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "DABigInteger")) [TcActualPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))]))])
%%% z_u is a variable!
mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
TSig {
  tType:  mp.DABigInteger
  tSupers: 
  tImpls:  mp.DataFieldAttribute<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
  bools:  [True,False]
  tMembers: 
  TypeMap {
    fields =>
      { value -->
          VSig {
            varType:  java.math.BigInteger
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,True]
          }
      }
    methods =>
      { ZERO -->
          { ([policy q],[],False) -->
              MSig {
                mRetType:  mp.DABigInteger<q>
                mRetPol:  q RealPolicy (TcRigidVar False "q")
                mPars:  []
                mParBounds:  []
              }
          }
        add -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [that]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        bitLength -->
          { ([],[],False) -->
              MSig {
                mRetType:  int
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        byteLength -->
          { ([],[],False) -->
              MSig {
                mRetType:  int
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        compareTo -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  int
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [that]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        getValue -->
          { ([],[],False) -->
              MSig {
                mRetType:  java.math.BigInteger
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        mod -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [that]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        modInverse -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [that]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        multiply -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [that]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        probablePrime -->
          { ([policy p],[int,java.util.Random<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [bitLength,rnd]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        subtract -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [that]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        toByteArray -->
          { ([],[],False) -->
              MSig {
                mRetType:  byte[]<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        toString -->
          { ([],[],False) -->
              MSig {
                mRetType:  java.lang.String
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
      }
    constrs =>
      { ([],[int,int,java.util.Random<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
          CSig {
            cPars:  [bitLength,certainty,rnd]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
        ([],[int,java.util.Random<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
          CSig {
            cPars:  [numBits,rnd]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
        ([],[java.lang.String],False) -->
          CSig {
            cPars:  [val]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
        ([],[java.math.BigInteger],False) -->
          CSig {
            cPars:  [val]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
      }
    locks =>{}
    policies =>{}
    actors =>{}
    typemethods =>{}
    types =>{}
    packages =>{}
  }
}
{ ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
    MSig {
      mRetType:  int
      mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
      mPars:  [that]
      mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
    }
}
findBestMethod: 
  Candidates: 
    ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False)
  Argument types: 
    [mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>]
isApplicable: (False,["mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>"],["mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>"])
     .... [[{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]]
Best method done
msig: MSig {
  mRetType:  int
  mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
  mPars:  [that]
  mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
}

##   z_u = null    ##

%%% z_u is a variable!
mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
Done with assignment

##   matrix = new mp.PermutationMatrix<secret>(p, z_u)    ##

Var: matrix (TcInstance (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "PermutationMatrix")) [TcActualPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))]) [],RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))
Var: p (TcType (TcRefT (TcArrayT (TcPrimT (ByteT ())) (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])))),RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))
%%% z_u is a variable!
mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>


######## Looking up constructor! ######## 

typ: mp.PermutationMatrix<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
cMap: 
{ ([],[java.util.ArrayList<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
    CSig {
      cPars:  [v]
      cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
    }
  ([],[byte[]<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>,mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
    CSig {
      cPars:  [b,z]
      cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
    }
}
findBestMethod: 
  Candidates: 
    ([],[java.util.ArrayList<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False)
    ([],[byte[]<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>,mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False)
  Argument types: 
    [byte[]<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>,mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>]
isApplicable: (False,["java.util.ArrayList<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>"],["byte[]<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>","mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>"])
     .... Nope
isApplicable: (False,["byte[]<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>","mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>"],["byte[]<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>","mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>"])
     .... [[{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}],[{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]]
Best method done
Done with assignment

##   matrixCopy = matrix.cloneMatrix()    ##

Var: matrixCopy (TcInstance (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "PermutationMatrix")) [TcActualPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))]) [],RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))
Var: matrix (TcInstance (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "PermutationMatrix")) [TcActualPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))]) [],RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))
TSig {
  tType:  mp.PermutationMatrix
  tSupers: 
  tImpls: 
  bools:  [True,False]
  tMembers: 
  TypeMap {
    fields =>
      { bitLength -->
          VSig {
            varType:  int
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,False]
          }
        matrix -->
          VSig {
            varType:  java.util.ArrayList<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,False]
          }
      }
    methods =>
      { cloneMatrix -->
          { ([],[],False) -->
              MSig {
                mRetType:  mp.PermutationMatrix<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        getDigest -->
          { ([],[],False) -->
              MSig {
                mRetType:  mp.Digest<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        getMatrix -->
          { ([],[],False) -->
              MSig {
                mRetType:  java.util.ArrayList<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        setNonZero -->
          { ([],[int,mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  void
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [i,z]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        toByteArray -->
          { ([],[],False) -->
              MSig {
                mRetType:  byte[]<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        toString -->
          { ([],[],False) -->
              MSig {
                mRetType:  java.lang.String
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        validate -->
          { ([],[byte[]<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>,mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  boolean
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [b,z]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
      }
    constrs =>
      { ([],[java.util.ArrayList<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
          CSig {
            cPars:  [v]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
        ([],[byte[]<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>,mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
          CSig {
            cPars:  [b,z]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
      }
    locks =>{}
    policies =>{}
    actors =>{}
    typemethods =>{}
    types =>{}
    packages =>{}
  }
}
lookupMethod: (Just (Name () EName Nothing (Ident () "matrix")),Ident () "cloneMatrix",[])
Var: matrix (TcInstance (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "PermutationMatrix")) [TcActualPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))]) [],RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))
TSig {
  tType:  mp.PermutationMatrix
  tSupers: 
  tImpls: 
  bools:  [True,False]
  tMembers: 
  TypeMap {
    fields =>
      { bitLength -->
          VSig {
            varType:  int
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,False]
          }
        matrix -->
          VSig {
            varType:  java.util.ArrayList<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,False]
          }
      }
    methods =>
      { cloneMatrix -->
          { ([],[],False) -->
              MSig {
                mRetType:  mp.PermutationMatrix<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        getDigest -->
          { ([],[],False) -->
              MSig {
                mRetType:  mp.Digest<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        getMatrix -->
          { ([],[],False) -->
              MSig {
                mRetType:  java.util.ArrayList<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        setNonZero -->
          { ([],[int,mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  void
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [i,z]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        toByteArray -->
          { ([],[],False) -->
              MSig {
                mRetType:  byte[]<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        toString -->
          { ([],[],False) -->
              MSig {
                mRetType:  java.lang.String
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        validate -->
          { ([],[byte[]<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>,mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  boolean
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [b,z]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
      }
    constrs =>
      { ([],[java.util.ArrayList<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
          CSig {
            cPars:  [v]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
        ([],[byte[]<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>,mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
          CSig {
            cPars:  [b,z]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
      }
    locks =>{}
    policies =>{}
    actors =>{}
    typemethods =>{}
    types =>{}
    packages =>{}
  }
}
{ ([],[],False) -->
    MSig {
      mRetType:  mp.PermutationMatrix<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
      mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
      mPars:  []
      mParBounds:  []
    }
}
findBestMethod: 
  Candidates: 
    ([],[],False)
  Argument types: 
    []
isApplicable: (False,[],[])
     .... []
Best method done
msig: MSig {
  mRetType:  mp.PermutationMatrix<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
  mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
  mPars:  []
  mParBounds:  []
}
Done with assignment

##   C_p = matrix.getDigest()    ##

%%% C_p is a variable!
mp.Digest<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
Var: matrix (TcInstance (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "PermutationMatrix")) [TcActualPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))]) [],RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))
TSig {
  tType:  mp.PermutationMatrix
  tSupers: 
  tImpls: 
  bools:  [True,False]
  tMembers: 
  TypeMap {
    fields =>
      { bitLength -->
          VSig {
            varType:  int
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,False]
          }
        matrix -->
          VSig {
            varType:  java.util.ArrayList<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,False]
          }
      }
    methods =>
      { cloneMatrix -->
          { ([],[],False) -->
              MSig {
                mRetType:  mp.PermutationMatrix<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        getDigest -->
          { ([],[],False) -->
              MSig {
                mRetType:  mp.Digest<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        getMatrix -->
          { ([],[],False) -->
              MSig {
                mRetType:  java.util.ArrayList<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        setNonZero -->
          { ([],[int,mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  void
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [i,z]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        toByteArray -->
          { ([],[],False) -->
              MSig {
                mRetType:  byte[]<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        toString -->
          { ([],[],False) -->
              MSig {
                mRetType:  java.lang.String
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        validate -->
          { ([],[byte[]<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>,mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  boolean
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [b,z]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
      }
    constrs =>
      { ([],[java.util.ArrayList<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
          CSig {
            cPars:  [v]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
        ([],[byte[]<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>,mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
          CSig {
            cPars:  [b,z]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
      }
    locks =>{}
    policies =>{}
    actors =>{}
    typemethods =>{}
    types =>{}
    packages =>{}
  }
}
lookupMethod: (Just (Name () EName Nothing (Ident () "matrix")),Ident () "getDigest",[])
Var: matrix (TcInstance (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "PermutationMatrix")) [TcActualPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))]) [],RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))
TSig {
  tType:  mp.PermutationMatrix
  tSupers: 
  tImpls: 
  bools:  [True,False]
  tMembers: 
  TypeMap {
    fields =>
      { bitLength -->
          VSig {
            varType:  int
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,False]
          }
        matrix -->
          VSig {
            varType:  java.util.ArrayList<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,False]
          }
      }
    methods =>
      { cloneMatrix -->
          { ([],[],False) -->
              MSig {
                mRetType:  mp.PermutationMatrix<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        getDigest -->
          { ([],[],False) -->
              MSig {
                mRetType:  mp.Digest<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        getMatrix -->
          { ([],[],False) -->
              MSig {
                mRetType:  java.util.ArrayList<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        setNonZero -->
          { ([],[int,mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  void
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [i,z]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        toByteArray -->
          { ([],[],False) -->
              MSig {
                mRetType:  byte[]<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        toString -->
          { ([],[],False) -->
              MSig {
                mRetType:  java.lang.String
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        validate -->
          { ([],[byte[]<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>,mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  boolean
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [b,z]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
      }
    constrs =>
      { ([],[java.util.ArrayList<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
          CSig {
            cPars:  [v]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
        ([],[byte[]<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>,mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
          CSig {
            cPars:  [b,z]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
      }
    locks =>{}
    policies =>{}
    actors =>{}
    typemethods =>{}
    types =>{}
    packages =>{}
  }
}
{ ([],[],False) -->
    MSig {
      mRetType:  mp.Digest<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
      mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
      mPars:  []
      mParBounds:  []
    }
}
findBestMethod: 
  Candidates: 
    ([],[],False)
  Argument types: 
    []
isApplicable: (False,[],[])
     .... []
Best method done
msig: MSig {
  mRetType:  mp.Digest<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
  mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
  mPars:  []
  mParBounds:  []
}
Done with assignment

####    s = DECKSIZE + 2    ####

Var: DECKSIZE (TcType (TcPrimT (IntT ())),RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []]))

####    delta = new mp.BigIntVector<secret>(s)    ####

%%% s is a variable!
int


######## Looking up constructor! ######## 

typ: mp.BigIntVector<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
cMap: 
{ ([],[],False) -->
    CSig {
      cPars:  []
      cParBounds:  []
    }
  ([],[int],False) -->
    CSig {
      cPars:  [initialCapacity]
      cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
    }
}
findBestMethod: 
  Candidates: 
    ([],[],False)
    ([],[int],False)
  Argument types: 
    [int]
isApplicable: (False,[],["int"])
     .... Nope
isApplicable: (False,["int"],["int"])
     .... []
Best method done

####    eps = new mp.BigIntVector<secret>(s)    ####

%%% s is a variable!
int


######## Looking up constructor! ######## 

typ: mp.BigIntVector<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
cMap: 
{ ([],[],False) -->
    CSig {
      cPars:  []
      cParBounds:  []
    }
  ([],[int],False) -->
    CSig {
      cPars:  [initialCapacity]
      cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
    }
}
findBestMethod: 
  Candidates: 
    ([],[],False)
    ([],[int],False)
  Argument types: 
    [int]
isApplicable: (False,[],["int"])
     .... Nope
isApplicable: (False,["int"],["int"])
     .... []
Best method done

####    dsum = d.getPHI(0)    ####

%%% d is a variable!
mp.PHIntVector<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
TSig {
  tType:  mp.PHIntVector
  tSupers:  java.util.ArrayList<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
  tImpls:  mp.DataFieldAttribute<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
  bools:  [True,False]
  tMembers: 
  TypeMap {
    fields =>{}
    methods =>
      { add -->
          { ([],[int,java.lang.Object],False) -->
              MSig {
                mRetType:  void
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [pos,s]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
            ([],[java.lang.Object],False) -->
              MSig {
                mRetType:  void
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [s]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        ensureCapacity -->
          { ([],[int],False) -->
              MSig {
                mRetType:  void
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [c]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        get -->
          { ([],[int],False) -->
              MSig {
                mRetType:  java.lang.Object
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} * policyof(i) RealPolicy (TcJoin (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]) (TcRigidVar True "i"))
                mPars:  [i]
                mParBounds:  [policyof(i)]
              }
          }
        getPHI -->
          { ([],[int],False) -->
              MSig {
                mRetType:  mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [i]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        set -->
          { ([],[int,java.lang.Object],False) -->
              MSig {
                mRetType:  void
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [pos,s]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        size -->
          { ([],[],False) -->
              MSig {
                mRetType:  int
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        toString -->
          { ([],[],False) -->
              MSig {
                mRetType:  java.lang.String
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
      }
    constrs =>
      { ([],[],False) -->
          CSig {
            cPars:  []
            cParBounds:  []
          }
      }
    locks =>{}
    policies =>{}
    actors =>{}
    typemethods =>{}
    types =>{}
    packages =>{}
  }
}
lookupMethod: (Just (Name () EName Nothing (Ident () "d")),Ident () "getPHI",[TcPrimT (IntT ())])
%%% d is a variable!
mp.PHIntVector<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
TSig {
  tType:  mp.PHIntVector
  tSupers:  java.util.ArrayList<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
  tImpls:  mp.DataFieldAttribute<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
  bools:  [True,False]
  tMembers: 
  TypeMap {
    fields =>{}
    methods =>
      { add -->
          { ([],[int,java.lang.Object],False) -->
              MSig {
                mRetType:  void
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [pos,s]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
            ([],[java.lang.Object],False) -->
              MSig {
                mRetType:  void
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [s]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        ensureCapacity -->
          { ([],[int],False) -->
              MSig {
                mRetType:  void
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [c]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        get -->
          { ([],[int],False) -->
              MSig {
                mRetType:  java.lang.Object
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} * policyof(i) RealPolicy (TcJoin (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]) (TcRigidVar True "i"))
                mPars:  [i]
                mParBounds:  [policyof(i)]
              }
          }
        getPHI -->
          { ([],[int],False) -->
              MSig {
                mRetType:  mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [i]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        set -->
          { ([],[int,java.lang.Object],False) -->
              MSig {
                mRetType:  void
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [pos,s]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        size -->
          { ([],[],False) -->
              MSig {
                mRetType:  int
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        toString -->
          { ([],[],False) -->
              MSig {
                mRetType:  java.lang.String
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
      }
    constrs =>
      { ([],[],False) -->
          CSig {
            cPars:  []
            cParBounds:  []
          }
      }
    locks =>{}
    policies =>{}
    actors =>{}
    typemethods =>{}
    types =>{}
    packages =>{}
  }
}
{ ([],[int],False) -->
    MSig {
      mRetType:  mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
      mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
      mPars:  [i]
      mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
    }
}
findBestMethod: 
  Candidates: 
    ([],[int],False)
  Argument types: 
    [int]
isApplicable: (False,["int"],["int"])
     .... []
Best method done
msig: MSig {
  mRetType:  mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
  mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
  mPars:  [i]
  mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
}

####    i = 1    ####

%%% i is a variable!
int
%%% s is a variable!
int

##   dsum = dsum.add(d.getPHI(i))    ##

%%% dsum is a variable!
mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
%%% dsum is a variable!
mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
TSig {
  tType:  mp.PHInteger
  tSupers: 
  tImpls:  mp.DataFieldAttribute<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
  bools:  [True,False]
  tMembers: 
  TypeMap {
    fields =>
      { value -->
          VSig {
            varType:  java.util.ArrayList<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,False]
          }
      }
    methods =>
      { add -->
          { ([],[mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [phi]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        getValueVector -->
          { ([],[],False) -->
              MSig {
                mRetType:  java.util.ArrayList<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        toString -->
          { ([],[],False) -->
              MSig {
                mRetType:  java.lang.String
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
      }
    constrs =>
      { ([],[java.util.ArrayList<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
          CSig {
            cPars:  [v]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
      }
    locks =>{}
    policies =>{}
    actors =>{}
    typemethods =>{}
    types =>{}
    packages =>{}
  }
}
%%% d is a variable!
mp.PHIntVector<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
TSig {
  tType:  mp.PHIntVector
  tSupers:  java.util.ArrayList<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
  tImpls:  mp.DataFieldAttribute<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
  bools:  [True,False]
  tMembers: 
  TypeMap {
    fields =>{}
    methods =>
      { add -->
          { ([],[int,java.lang.Object],False) -->
              MSig {
                mRetType:  void
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [pos,s]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
            ([],[java.lang.Object],False) -->
              MSig {
                mRetType:  void
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [s]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        ensureCapacity -->
          { ([],[int],False) -->
              MSig {
                mRetType:  void
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [c]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        get -->
          { ([],[int],False) -->
              MSig {
                mRetType:  java.lang.Object
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} * policyof(i) RealPolicy (TcJoin (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]) (TcRigidVar True "i"))
                mPars:  [i]
                mParBounds:  [policyof(i)]
              }
          }
        getPHI -->
          { ([],[int],False) -->
              MSig {
                mRetType:  mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [i]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        set -->
          { ([],[int,java.lang.Object],False) -->
              MSig {
                mRetType:  void
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [pos,s]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        size -->
          { ([],[],False) -->
              MSig {
                mRetType:  int
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        toString -->
          { ([],[],False) -->
              MSig {
                mRetType:  java.lang.String
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
      }
    constrs =>
      { ([],[],False) -->
          CSig {
            cPars:  []
            cParBounds:  []
          }
      }
    locks =>{}
    policies =>{}
    actors =>{}
    typemethods =>{}
    types =>{}
    packages =>{}
  }
}
%%% i is a variable!
int
lookupMethod: (Just (Name () EName Nothing (Ident () "d")),Ident () "getPHI",[TcPrimT (IntT ())])
%%% d is a variable!
mp.PHIntVector<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
TSig {
  tType:  mp.PHIntVector
  tSupers:  java.util.ArrayList<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
  tImpls:  mp.DataFieldAttribute<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
  bools:  [True,False]
  tMembers: 
  TypeMap {
    fields =>{}
    methods =>
      { add -->
          { ([],[int,java.lang.Object],False) -->
              MSig {
                mRetType:  void
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [pos,s]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
            ([],[java.lang.Object],False) -->
              MSig {
                mRetType:  void
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [s]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        ensureCapacity -->
          { ([],[int],False) -->
              MSig {
                mRetType:  void
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [c]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        get -->
          { ([],[int],False) -->
              MSig {
                mRetType:  java.lang.Object
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} * policyof(i) RealPolicy (TcJoin (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]) (TcRigidVar True "i"))
                mPars:  [i]
                mParBounds:  [policyof(i)]
              }
          }
        getPHI -->
          { ([],[int],False) -->
              MSig {
                mRetType:  mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [i]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        set -->
          { ([],[int,java.lang.Object],False) -->
              MSig {
                mRetType:  void
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [pos,s]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        size -->
          { ([],[],False) -->
              MSig {
                mRetType:  int
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        toString -->
          { ([],[],False) -->
              MSig {
                mRetType:  java.lang.String
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
      }
    constrs =>
      { ([],[],False) -->
          CSig {
            cPars:  []
            cParBounds:  []
          }
      }
    locks =>{}
    policies =>{}
    actors =>{}
    typemethods =>{}
    types =>{}
    packages =>{}
  }
}
{ ([],[int],False) -->
    MSig {
      mRetType:  mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
      mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
      mPars:  [i]
      mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
    }
}
findBestMethod: 
  Candidates: 
    ([],[int],False)
  Argument types: 
    [int]
isApplicable: (False,["int"],["int"])
     .... []
Best method done
msig: MSig {
  mRetType:  mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
  mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
  mPars:  [i]
  mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
}
lookupMethod: (Just (Name () EName Nothing (Ident () "dsum")),Ident () "add",[TcRefT (TcClsRefT (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "PHInteger")) [TcActualPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))]))])
%%% dsum is a variable!
mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
TSig {
  tType:  mp.PHInteger
  tSupers: 
  tImpls:  mp.DataFieldAttribute<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
  bools:  [True,False]
  tMembers: 
  TypeMap {
    fields =>
      { value -->
          VSig {
            varType:  java.util.ArrayList<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,False]
          }
      }
    methods =>
      { add -->
          { ([],[mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [phi]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        getValueVector -->
          { ([],[],False) -->
              MSig {
                mRetType:  java.util.ArrayList<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
        toString -->
          { ([],[],False) -->
              MSig {
                mRetType:  java.lang.String
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
      }
    constrs =>
      { ([],[java.util.ArrayList<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
          CSig {
            cPars:  [v]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
      }
    locks =>{}
    policies =>{}
    actors =>{}
    typemethods =>{}
    types =>{}
    packages =>{}
  }
}
{ ([],[mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
    MSig {
      mRetType:  mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
      mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
      mPars:  [phi]
      mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
    }
}
findBestMethod: 
  Candidates: 
    ([],[mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False)
  Argument types: 
    [mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>]
isApplicable: (False,["mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>"],["mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>"])
     .... [[{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]]
Best method done
msig: MSig {
  mRetType:  mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
  mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
  mPars:  [phi]
  mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
}
Done with assignment
%%% i is a variable!
int

####    dSumDecrypted = ph.decrypt(dsum)    ####

Var: ph (TcInstance (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "PHCrypto")) [TcActualPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))]) [],RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))
TSig {
  tType:  mp.PHCrypto
  tSupers: 
  tImpls: 
  bools:  [True,False]
  tMembers: 
  TypeMap {
    fields =>
      { BITLENGTH -->
          VSig {
            varType:  int
            varPol:  {'x:}
            bools:  [False,False,True]
          }
        m -->
          VSig {
            varType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,True]
          }
        nlength -->
          VSig {
            varType:  int
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,False]
          }
        p -->
          VSig {
            varType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,True]
          }
        q -->
          VSig {
            varType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,True]
          }
        rp -->
          VSig {
            varType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,False]
          }
        rq -->
          VSig {
            varType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,False]
          }
        sha1 -->
          VSig {
            varType:  java.lang.String
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,False]
          }
      }
    methods =>
      { decrypt -->
          { ([],[mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [encr]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        encrypt -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>,int],False) -->
              MSig {
                mRetType:  mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [_a,_n]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        encryptCardVector -->
          { ([],[mp.CardVector<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>,int],False) -->
              MSig {
                mRetType:  mp.EncryptedCardVector<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [w,n]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        generateR -->
          { ([],[],False) -->
              MSig {
                mRetType:  void
                mRetPol:  {'x:} RealPolicy (TcPolicy [TcClause (TcVar "x") []])
                mPars:  []
                mParBounds:  []
              }
          }
        getPublicParam -->
          { ([],[],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
      }
    constrs =>
      { ([],[int],False) -->
          CSig {
            cPars:  [n]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
      }
    locks =>{}
    policies =>{}
    actors =>{}
    typemethods =>{}
    types =>{}
    packages =>{}
  }
}
%%% dsum is a variable!
mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
lookupMethod: (Just (Name () EName Nothing (Ident () "ph")),Ident () "decrypt",[TcRefT (TcClsRefT (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "PHInteger")) [TcActualPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))]))])
Var: ph (TcInstance (TcClassT (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "PHCrypto")) [TcActualPolicy (RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))]) [],RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]]))
TSig {
  tType:  mp.PHCrypto
  tSupers: 
  tImpls: 
  bools:  [True,False]
  tMembers: 
  TypeMap {
    fields =>
      { BITLENGTH -->
          VSig {
            varType:  int
            varPol:  {'x:}
            bools:  [False,False,True]
          }
        m -->
          VSig {
            varType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,True]
          }
        nlength -->
          VSig {
            varType:  int
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,False]
          }
        p -->
          VSig {
            varType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,True]
          }
        q -->
          VSig {
            varType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,True]
          }
        rp -->
          VSig {
            varType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,False]
          }
        rq -->
          VSig {
            varType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,False]
          }
        sha1 -->
          VSig {
            varType:  java.lang.String
            varPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}
            bools:  [False,False,False]
          }
      }
    methods =>
      { decrypt -->
          { ([],[mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [encr]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        encrypt -->
          { ([],[mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>,int],False) -->
              MSig {
                mRetType:  mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [_a,_n]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        encryptCardVector -->
          { ([],[mp.CardVector<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>,int],False) -->
              MSig {
                mRetType:  mp.EncryptedCardVector<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  [w,n]
                mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
              }
          }
        generateR -->
          { ([],[],False) -->
              MSig {
                mRetType:  void
                mRetPol:  {'x:} RealPolicy (TcPolicy [TcClause (TcVar "x") []])
                mPars:  []
                mParBounds:  []
              }
          }
        getPublicParam -->
          { ([],[],False) -->
              MSig {
                mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
                mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
                mPars:  []
                mParBounds:  []
              }
          }
      }
    constrs =>
      { ([],[int],False) -->
          CSig {
            cPars:  [n]
            cParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
          }
      }
    locks =>{}
    policies =>{}
    actors =>{}
    typemethods =>{}
    types =>{}
    packages =>{}
  }
}
{ ([],[mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False) -->
    MSig {
      mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
      mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
      mPars:  [encr]
      mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
    }
}
findBestMethod: 
  Candidates: 
    ([],[mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>],False)
  Argument types: 
    [mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>]
isApplicable: (False,["mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>"],["mp.PHInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>"])
     .... [[{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify},{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]]
Best method done
msig: MSig {
  mRetType:  mp.DABigInteger<{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}>
  mRetPol:  {channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify} RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
  mPars:  [encr]
  mParBounds:  [{channel#0: mp.GameState.GameEnded;channel#0: mp.TrustedDeclassifier.Declassify}]
}
Solving constraints...
23
Constraints successfully solved!
Type-checking method private !secret ?secret byte[]<secret> generatePermutation()
;
pRet: RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "GameState"))) (Ident () "GameEnded")) []],TcClause (TcActor (Fresh 0 "channel")) [TcAtom (Name () LName (Just (Name () TName (Just (Name () PName Nothing (Ident () "mp"))) (Ident () "TrustedDeclassifier"))) (Ident () "Declassify")) []]])
Solving constraints...
0
Constraints successfully solved!
Type-checking method public !everyone void drawCard(?everyone int card) throws !everyone java.lang.IllegalArgumentException, !everyone mp.MPException, !everyone java.lang.SecurityException
;
pRet: RealPolicy (TcPolicy [TcClause (TcActor (Fresh 0 "channel")) []])
Solving constraints...
0
Constraints successfully solved!
Type-checking method public !everyone void processCardDraw() throws !everyone java.lang.IllegalArgumentException, !everyone mp.MPException, !everyone java.lang.SecurityException
;
pRet: RealPolicy (TcPolicy [TcClause (TcVar "x") []])
Solving constraints...
0
Constraints successfully solved!
Type-checking method public !everyone void processSelfCardDraw() throws !everyone mp.MPException, !everyone java.lang.SecurityException
;
pRet: RealPolicy (TcPolicy [TcClause (TcVar "x") []])
Solving constraints...
0
Constraints successfully solved!
Type checking complete!
File generation complete!

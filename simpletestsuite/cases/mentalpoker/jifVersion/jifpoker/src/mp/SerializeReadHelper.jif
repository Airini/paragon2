/* Jif poker - an implementation of mental poker protocol in Jif
 * (C) 2005 Aslan Askarov
 */
package mp;
import java.io.BufferedReader;
import java.io.IOException;
import jif.util.ArrayList;


public class SerializeReadHelper[label L]{
    
    private final BufferedReader[L]{L} reader;
    
    
    public SerializeReadHelper( BufferedReader[L]{L} reader):{L}
    throws IllegalArgumentException {     
        this.reader = reader;
        if (reader == null)
           throw new IllegalArgumentException("reader is null");
    }
    
    // line which has been read from stdin...
    private String{L} line = null;
    
    // integer position of the amount of read symbols in the line...
    private int{L} pos = 0;

    // very inefficient implementation !!!
    // but should work...
    // we have side effect here
    // since the method affects this.line member variable...
    
    private String readString{L}():{L} throws MPException, IOException{
        String line = this.line;
        if (line != null) line = line.trim();        

        BufferedReader[L] reader = this.reader;
        if (reader == null) 
            throw new MPException("readString: reader is null");
        
        // attempt to read once from the stream
        if (line == null || line.length() == 0) {
            line = reader.readLine();
            pos = 0;
            if (line == null)
                return null;
            else 
                line = line.trim();
        }
        
        // line is not null now...
        // parse and return whatever we have before the first space...
        try {
            int j = pos;
            while (j < line.length()
                && !Character.isWhitespace(line.charAt(j))) {
                j++;
            }
            String v  = line.substring(pos, j);
            this.line = line.substring(j).trim();
                   
            return v;
        } catch (NullPointerException e) {
            throw new MPException("readString: NPE");
        } catch (StringIndexOutOfBoundsException e) {
            throw new MPException("readString: IOB");
        }
    }
    
    private int readInt{L}():{L} 
    throws MPException, NumberFormatException, IOException{
        String v = readString();
        return Integer.parseInt(v);                           
    }
    
    private byte readByte{L}():{L}
    throws MPException, NumberFormatException, IOException {
        int ival = readInt();
        return (byte) ival;
    }
    
    public DABigInteger[L]{L} readBigInt{L}():{L} 
    throws MPException, IOException {
        String type = readString();
        if (type == null)
            throw new MPException("readBigInt: null type input");
        if (0 != type.compareTo("###BIGINT"))
             throw new MPException("readBigInt: invalid format"); 
        String{} value = readString();
        if (value == null)
            throw new MPException("readBigInt: null value input");        
        if (value.compareTo("NULL") == 0)
             return null;
        try {
            DABigInteger[L] x = new DABigInteger[L](value);
            return x;
        } catch (NumberFormatException e) {
            throw new MPException("readBigInt: NFE");
        }        
    }

    public BigIntPair[L]{L} readBigIntPair{L}():{L} throws MPException, IOException{
        String type = readString();
        if (type == null)
            throw new MPException("readBigIntPair: null type input");
        if (0 != type.compareTo("###BIGINTPAIR"))
            throw new MPException("readBigIntPair: invalid format");
        String{} value = readString();
        if (value == null)
            throw new MPException("readBigIntPair: null value input"); 
        if (value.compareTo("NULL") == 0)
            return null;
        
        DABigInteger[L] x = readBigInt();
        DABigInteger[L] y = readBigInt();
    
        return new BigIntPair[L](x,y);
    }
        
    public PHInteger[L]{L} readPHInt{L}():{L} throws MPException, IOException{
        String type = readString();
        if (type == null)
            throw new MPException("readPHInt: null type input");
        if (0 != type.compareTo("###PHINT"))
           throw new MPException("readPHInt: invalid format");
        
        ArrayList [L]{L} y = new ArrayList[L]();
        
        try {
            int t = readInt();
            y.ensureCapacity(t);
            for (int i = 0; i < t; i++)
                y.add (readBigIntPair());
        } catch (NumberFormatException e) {
            return null;
        }
        return new PHInteger[L](y);
    }

    public PHIntVector[L]{L} readPHIntVector{L}():{L}
    throws MPException, IOException{
        String type = readString();
        if (type == null)
            throw new MPException("readPHIntVector: null type input");
        if (0 != type.compareTo("###PHINTVECTOR"))
            throw new MPException("readPHIntVector: invalid format");
        PHIntVector[L]{L} y = new PHIntVector[L]();
        try {
            int t = readInt();
            y.ensureCapacity(t);
            for (int i = 0; i < t; i++)
                y.add(readPHInt());
        } catch (NumberFormatException e) {
            return null;
        }            
        return y;
    }

    public BigIntVector[L]{L} readBigIntVector{L}():{L}
    throws MPException, IOException{
        String type = readString();
         if (type == null)
            throw new MPException("readBigIntVector: null type input");
      
        if (0 != type.compareTo("###BIGINTVECTOR") )
            throw new MPException("readBigIntVector: invalid format");
        BigIntVector[L]{L} y = new BigIntVector[L]();
        try {
            int t = readInt();
            y.ensureCapacity(t);
            for (int i = 0; i < t; i++)
                y.add(readBigInt());
        } catch (NumberFormatException e) {
            return null;
        }
        return y;
    }

    public CardVector[L]{L} readCardVector{L}():{L} 
    throws MPException, IOException{
        String type = readString();
        if (type == null)
            throw new MPException("readCardVector: null type input");
      
        if (0 != type.compareTo("###CARDVECTOR"))
            throw new MPException("readCardVector: invalid format");
        String value = readString();
         if (value == null)
            throw new MPException("readPHIntVector: null value input");
      
        if (value.compareTo("NULL") == 0)
            return null;
        BigIntVector[L] biv = readBigIntVector();
        try {
            return new CardVector[L](biv);
        } catch (IllegalArgumentException e) {
            return null;
        }
    }


    public EncryptedCardVector[L]{L} readEncCardVector{L}():{L}
    throws MPException, IOException{
        String type = readString();
        if (type == null)
            throw new MPException("readEncCardVector: null type input");
        if (0 != type.compareTo("###ENCCARDVECTOR"))
            throw new MPException("readEncCardVector: invalid format");
        String value = readString();
        if (value == null)
            throw new MPException("readEncCardVector; null value input");
        if (value.compareTo("NULL") == 0)
            return null;
        PHIntVector[L] phv = readPHIntVector();
        try {
            return new EncryptedCardVector[L](phv);
        } catch (IllegalArgumentException e) {
            return null;
        }
    }

    public byte{L}[]{L} readByteArray{L}():{L}
    throws MPException, IOException{
        String type = readString();
        if (type == null)
            throw new MPException("readByteArray: null type input");
        if (0 != type.compareTo("###BYTEARRAY"))
            throw new MPException("readByteArray: invalid format");

        int t ;
        
        try {
            t = readInt();
        } catch (NumberFormatException e) {
            return null;
        }
        
        String value = readString();
        if (value == null)
            throw new MPException("readByteArray: null value input");
        if (0 != value.compareTo("###BYTES"))
            throw new MPException("readByteArray: invalid format " + value);
        byte{L}[] y = new byte[t];
        try {
           
            for (int i = 0; i < t; i++)
                y[i] = readByte( );
           
        } catch (ArrayIndexOutOfBoundsException ignored) {
        } catch (NumberFormatException e) {
            throw new MPException("readByteArray: invalid format");
        }
        return y;
    }

    public Digest[L]{L} readDigest{L}():{L} 
    throws MPException, IOException{
        String type = readString();
        if (type == null)
            throw new MPException("readDigest: null type input");
        if (0 != type.compareTo("###DIGEST"))
            throw new MPException("readDigest: invalid format");
        String value = readString();
        if (value == null)
            throw new MPException("readDigest: null value input");
        if (value.compareTo("NULL") == 0)
            return null;
        byte{L}[]{L} ba = readByteArray();
        return new Digest[L](ba);       
    }

    public DataFieldAttribute[L] readAttribute{L}():{L}
    throws MPException, IOException {
        // read the value from the string 
        // and put it back... so that it can be parsed 
        // further
        String type = readString();
        if (type == null)
            throw new MPException("readAttribute: null type input");
        // put back so that it can be used further
        this.line = type +" " + line;
        if (type.compareTo ( "###ENCCARDVECTOR") == 0)             
            return readEncCardVector();
        else if (type.compareTo( "###CARDVECTOR") == 0) 
            return readCardVector();
        else if (type.compareTo("###BIGINTVECTOR") == 0) 
            return readBigIntVector();
        else if (type.compareTo ("###PHINTVECTOR") == 0)
            return readPHIntVector();
        else if (type.compareTo( "###BIGINT") == 0 )
            return readBigInt();       
        else if (type.compareTo ("###DIGEST") ==0 )
            return readDigest();
        else if (type.compareTo ( "###DAVECTOR") == 0)
            return readDAVector();
        
        throw new MPException("readAttribute: unknown type" + type);
    }
             
        
        
            

    public DAVector[L]{L} readDAVector{L}():{L}
    throws MPException, IOException{
        String type = readString();
        if (type == null)
            throw new MPException("readDAVector: null type input");
        if (0 != type.compareTo("###DAVECTOR"))
            throw new MPException("readDAVector: invalid format");
        DAVector [L] y = new DAVector[L]();
        try {
            int t = readInt();
            y.ensureCapacity(t);
            for (int i =0 ; i < t; i++)
                y.add(readAttribute());
        } catch (NumberFormatException e) {
            return null;
        }
        return y;
    }

    
    public DNCLink[L]{L} readDNCLink{L}():{L}
    throws MPException, IOException {
        String type = readString();
        if (type == null)
            throw new MPException("readDNCLink: null input");
        if (type.compareTo("###DNCLINK") != 0) 
            throw new MPException("readDNCLink: unknown format " + type);
        
        // if (value == null)
            // throw new MPException("readDNCLink: null value input");
        // if (value.compareTo("NULL") == 0)
            // return null;
        int k;
        try {            
            k = readInt();
        } catch (NumberFormatException e) {
            return null;
            //throw new MPException("readDNCLink: invalid integer format");
        }
        
        DataField[L] data = readDataField();
      
        String value = readString();
        if (value == null)
            throw new MPException("readDNCLink: null value input");
        if (value.compareTo( "###CHAINVALUE") != 0)
            throw new MPException("readDNCLink: invalid format");
        
        byte{L}[] chval = readByteArray();
        return new DNCLink[L](k, data, chval);        
        
    }
    
    
    public DataField[L]{L} readDataField{L}():{L} 
    throws MPException, IOException {
        String type = readString();
        if (type == null)
            throw new MPException("readDataField: null type input");
        if (0 != type.compareTo("###DATAFIELD") )
            throw new MPException("readDataField: invalid type format " + type);
        String value = readString();
        if (value == null)
            throw new MPException("readDataField: null value input");
        if (value.compareTo("NULL") == 0)
            return null;
        String playerName = value;
        
        int tmstamp;
        try {
            tmstamp = readInt();
        } catch (NumberFormatException e) {
            throw new MPException("readDataField: invalid int format");
        }            
        String info  = readString();
        if (info == null)
            throw new MPException("readDataField: null info input");
        
        DataFieldAttribute[L] attrib = readAttribute();
        return new DataField[L](
            playerName,
            tmstamp,
            info,
            attrib);
        
    }
    
    
    public PermutationMatrix[L]{L} readMatrix{L}():{L}
    throws MPException, IOException {
        String type = readString();
        if (type == null)
            throw new MPException("readMatrix: null type input");
        if (0 != type.compareTo("###MATRIX"))
            throw new MPException("readMatrix: invalid type format " + type);
       
        ArrayList[L] y = new ArrayList[L]();
        int t ;
        
        try {
            t = readInt();
        } catch (NumberFormatException e ) {
            return null;
        }
        y.ensureCapacity(t);
        for (int i = 0; i < t; i++)
            y.add(readBigIntVector());
        try {
            return new PermutationMatrix[L](y);
        } catch (IllegalArgumentException e) {
            return null;
        }
        
    }
}

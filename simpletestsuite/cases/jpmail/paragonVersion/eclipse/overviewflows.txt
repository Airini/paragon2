Overview of information flows and policies within the Paragon version of JPMail.

::::: ParaJPMail Runtime

1) Runtime actors.

ParaJPMail comes with runtime classes that provide a link from a unix user 
identifier (a string) to a paragon actor, and from a jpmail user identifier
(also a string) to a paragon actor. These are simple hashmaps from identifier
to actor, and ensure that the same actor is returned for the same identifier.
The unix runtime also has an actor representing the user currently logged in.

2) Files.

The simple unix runtime provides an api for opening and reading a file's
content. Each file's content is wrapped in a UnixFile class that comes with an
instance actor serving as identifier for that file. The runtime determines which
actor represents the owner of this file (according to the unix owner of the 
file) and opens the lock FileOwner(fileid, owner) for that owner and file id.
The policy on the content of this file then becomes:
  { 'x : FileOwner(fd, 'x)
  ; 'y : FileOwner(fd, 'x), ShareContent(fd, 'x, 'y)
  };
The ShareContent lock is not opened by the system, but is public and can be
opened elsewhere in the program to explicitly share the content of the file.

TODO: The policy could be made more involved to better represent the unix file
permissions better (i.e. actors for groups etc.)

3) Debugging.

The runtime also comes with a class that allows for printing to standard out
that completely disregards information flow safety; i.e. information of any
level in the lattice can be printed. To have a safe execution the debug class
should be removed from the runtime environment upon deployment.

:::: Cryptography

1) Symmetric encryption.

The subpackage 'crypto' contains paragon files that present a simple API to
several symmetric and asymmetric encryption methods. The symmetric algorithms
are parametrized on policies to be placed on the data (after encryption) and on
the key + initialization vector generated by the encryption. Each encryption
class contains an 'Encrypted' lock, and performing encryption on data with
policy {'x : Encrypted} * p results in data with policy p. Decryption happens
entirely within one level in the lattice. Upon encryption a random key and iv
are generated. The resulting encryption gets policies on data and key/iv as 
specified by the caller. (Could be improved by parametrizing on the lock to be
opened for the sym. key).

TODO: The implementation of AES and DES is awfully similar - no way to somehow
abstract a bit here? -- Needs param. on locks?

2) Asymmetric encryption.

We intended to provide two asymmetric encrytion algorithms. However, since known
implementations of ECC automatically apply symmetric encryption on the data
first the information flow-interesting aspect gets lost there, hence we stick to
only providing RSA encryption. The RSA classes provides two static methods for
performing encryption and decryption. For encryption, it takes data with policy
{'x : Encrypted} * p returning data with policy p, similar to symmetric
encryption (but of course with a different lock). The policy on the public key
is also taken to be p. Decryption again happens on one level in the lattice, we
assume that protection of the private key happens outside the computation.

TODO: Provide ElGamal as an alternative asymmetric encryption.

:::: JPMail policies

1) Global Policies.

One class simply provides an easy interface to the global policy that public
information may flow to the current unix user and the network. This class might
disappear after reorganizing.

2) JPMail user - specified policies.

The class JPMailPolicy contains a variety on locks:
  (transitive reflexive) DelegatesTo (from, to);
Indicates that actor 'from' allows 'to' to handle for him. This can happen
between JPMail actors, as well as from a JPMail actor to a unix user.
  AllowsAESEncryption (jpmailActor);
  AllowsDESEncryption (jpmailActor);
  AllowsRSAEncryption (jpmailActor);
These locks indicated that, when opened, the specified JPMail actor trusts the
encryption represented by the lock, and emails sent to this actor can be
encrypted under this encryption. At the start of the JPMail program a policy
file is parsed and locks are opened accordingly. 

TODO: As long as the user is free to specify and change the policy file herself,
this does not prevent a user from disclosing information without encrypting it.
Of course, this is not in general possible (the user can just use a different
program) but perhaps we can require a bit more here still (e.g. file owned by
trusted user?) -- signed by CA?

:::: Email

1) Sending and receiving email.

The SMTPMail and the IMAP class provide a simple sending resp. receiving email
functionality. All information flows are within the same level of the lattice,
except for the password to the smtp / imap server which is protected with an
encapsulated (private) lock and cannot be opened outside the class, making it
effectively a trusted declassifier. 

2) Encrypted (JP) mails.

The class CryptedMail represents an email that has been encrypted according to
JPMail specifications. It can be serialized to be the body of a regular email.
It is parametrized on a policy and all information flow in that class is in
that level.

:::: UserSettings

1) User settings.

A user of the paraJPMail program needs to provide a settings file containing:
- server / login / password for the SMTP server
- server / login / password for the IMAP server
- location and password to a keystore
The UserSettings class asserts labels on this information, as well as on the 
information within the keystore. Those different from GlobalPol.publ are:
- password for SMTP server = GP.publ * {'x : SMTPPwd} -- trusted: SMTPMail
- password for IMAP server = GP.publ * {'x : IMAPPwd} -- trusted: IMAP
- password for keystore = { currentUser : 
                          ; network : keystoreLock }
- private keys = { currentUser : } -- no need to leave the local system

The keystore password might be declassified to network, because succesful access
to the keystore needs to be disclosed.

:::: The Main Program

1) MailBody.

This is an auxilary class. It mainly puts a policy on the mail body read by the
sendmail program. We could also place this policy directly on the input itself.
However, since we do not provide a GUI all user provided information enters the
programs via the stream (standard in) and is thus labeled the same. To give some
extra guarantee that we cannot use a mail body with a too liberal policy, the
method for declassifying an email body can only be called on MailBody. The
policy placed on the content is:
      AESEncryption.encPol * { currentUser : 
                             ; network : AllowsAESEncryption('x) , Receiver('x)
                             }
    + DESEncryption.encPol * { currentUser : 
                             ; network : AllowsDESEncryption('x), Receiver('x)
                             }
I.e., it can always flow to the user who typed the message, but only to the
network if the actor marked as receiver allows for appropriate encryption (and
that encryption is performed).

2) SendMail.

Main class for sending email. Reads and parses policies and user settings. Makes
sure that claimed jpmail identity can be acted for by the invoking unix user.
All input is labeled as GP.publ or relabaled as described above, including the
mail body. The lock Receiver(r) is opened for the user-provided Jpmail actor r
to who the email is addressed. The body is then declassified by first performing
encryption (if allowed for by the receiver), and placing the following policy on
the generated key + iv:
    RSAEncryption.encPol * { currentUser : 
                           ; network : AllowsRSAEncryption('x), Receiver('x)
                           }
  + ECCEncryption.encPol * { currentUser : 
                           ; network : AllowsECCEncryption('x), Receiver('x)
                           }
Similar to the policy on the mail body; this information can only be
declassified by an asymmetric algorithm allowed for by the receiver (ECC not
supported). Next, asymmetric encryption is applied if appropriate, getting the
public key from the keystore.

3) ReadMail.

The initial set up is very similar to sending emails (specifying and parsing
policy file and user settings). It is checked whether the claimed identity might
act for the unix user. Emails are read and their content is considered public,
since it is coming from the network (and supposedly encrypted). For each e-mail
it is checked if it carries the ParaJPMail header, and if the current jpmail
user is allowed to act for the receiver. If so, we try to find the private key
in the keystore (basically making the act-for check useless) and decrypt the
message. The result of decrypting is affected by the private key and can
therefore as specified by its policy only flow to the current unix user. Other
than that there are no interesting flows in this part of the program.

:::: Reorganization plans

Some plans on better organizing this implemenation:
- rename packages according to above
- reorder files
- move Receiver lock to some mail related class
- package for mail-related stuff?
- check for TODO and ISSUE tags...
